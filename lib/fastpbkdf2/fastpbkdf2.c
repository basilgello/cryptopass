/*
 * fast-pbkdf2 - Optimal PBKDF2-HMAC calculation
 * Written in 2015 by Joseph Birr-Pixton <jpixton@gmail.com>
 *
 * To the extent possible under law, the author(s) have dedicated all
 * copyright and related and neighboring rights to this software to the
 * public domain worldwide. This software is distributed without any
 * warranty.
 *
 * You should have received a copy of the CC0 Public Domain Dedication
 * along with this software. If not, see
 * <http://creativecommons.org/publicdomain/zero/1.0/>.
 */

#include "fastpbkdf2.h"

#include <assert.h>
#include <string.h>

/* --- MSVC doesn't support C99 --- */
#ifdef _MSC_VER
#define restrict
#define _Pragma __pragma
#endif

/* --- Common useful things --- */
#define MIN(a, b) ((a) > (b)) ? (b) : (a)
#define rotl32(x, n) (((x) << (n)) | ((x) >> (32 - (n))))
#define rotr32(x, n) (((x) >> (n)) | ((x) << (32 - (n))))
#define rotr64(x, n) (((x) >> (n)) | ((x) << (64 - (n))))

static inline uint32_t read32_be(const uint8_t x[4])
{
#if defined(__GNUC__) && __GNUC__ >= 4 &&                                      \
	__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
	return __builtin_bswap32(*(uint32_t *)(x));
#else
	uint32_t r = (uint32_t)(x[0]) << 24 | (uint32_t)(x[1]) << 16 |
		     (uint32_t)(x[2]) << 8 | (uint32_t)(x[3]);
	return r;
#endif
}

static inline void write32_be(uint32_t n, uint8_t out[4])
{
#if defined(__GNUC__) && __GNUC__ >= 4 &&                                      \
	__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
	*(uint32_t *)(out) = __builtin_bswap32(n);
#else
	out[0] = (n >> 24) & 0xff;
	out[1] = (n >> 16) & 0xff;
	out[2] = (n >> 8) & 0xff;
	out[3] = n & 0xff;
#endif
}

static inline uint64_t read64_be(const uint8_t x[8])
{
#if defined(__GNUC__) && __GNUC__ >= 4 &&                                      \
	__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
	return __builtin_bswap64(*(uint64_t *)(x));
#else
	uint64_t r = (uint64_t)(x[0]) << 56 | (uint64_t)(x[1]) << 48 |
		     (uint64_t)(x[2]) << 40 | (uint64_t)(x[3]) << 32 |
		     (uint64_t)(x[4]) << 24 | (uint64_t)(x[5]) << 16 |
		     (uint64_t)(x[6]) << 8 | (uint64_t)(x[7]);
	return r;
#endif
}

static inline void write64_be(uint64_t n, uint8_t out[8])
{
#if defined(__GNUC__) && __GNUC__ >= 4 &&                                      \
	__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
	*(uint64_t *)(out) = __builtin_bswap64(n);
#else
	write32_be((n >> 32) & 0xffffffff, out);
	write32_be(n & 0xffffffff, out + 4);
#endif
}

/* --- Optional OpenMP parallelisation of consecutive blocks --- */
#ifdef WITH_OPENMP
#define OPENMP_PARALLEL_FOR _Pragma("omp parallel for")
#else
#define OPENMP_PARALLEL_FOR
#endif

/* Prepare block (of blocksz bytes) to contain md padding denoting a msg-size
 * message (in bytes).  block has a prefix of used bytes.
 *
 * Message length is expressed in 32 bits (so suitable for sha1, sha256, sha512). */
static inline void md_pad(uint8_t *block, size_t blocksz, size_t used,
			  size_t msg)
{
	memset(block + used, 0, blocksz - used - 4);
	block[used] = 0x80;
	block += blocksz - 4;
	write32_be((uint32_t)(msg * 8), block);
}

#include "blockwise.inc.c"
#include "sha1.inc.c"
#include "sha256.inc.c"
#include "sha512.inc.c"

void fastpbkdf2_hmac_sha1(const uint8_t *pw, size_t npw, const uint8_t *salt,
			  size_t nsalt, uint32_t iterations, uint8_t *out,
			  size_t nout)
{
	PBKDF2(sha1)(pw, npw, salt, nsalt, iterations, out, nout);
}

void fastpbkdf2_hmac_sha256(const uint8_t *pw, size_t npw, const uint8_t *salt,
			    size_t nsalt, uint32_t iterations, uint8_t *out,
			    size_t nout)
{
	PBKDF2(sha256)(pw, npw, salt, nsalt, iterations, out, nout);
}

void fastpbkdf2_hmac_sha512(const uint8_t *pw, size_t npw, const uint8_t *salt,
			    size_t nsalt, uint32_t iterations, uint8_t *out,
			    size_t nout)
{
	PBKDF2(sha512)(pw, npw, salt, nsalt, iterations, out, nout);
}
